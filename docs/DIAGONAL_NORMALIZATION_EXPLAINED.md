# 对角线归一化原理详解

## ? 核心概念澄清

### ? 常见误解
> "归一化后，视频都变成统一尺寸了"

### ? 正确理解
> "归一化是统一了**度量标准**，而不是统一视频尺寸"

**视频尺寸不变**！只是改变了"如何衡量运动"。

---

## ? 归一化原理

### 类比：测量身高

想象测量不同人的身高：

| 方法 | 测量结果 | 问题 |
|------|---------|------|
| **绝对值** | 小明: 170cm, 大楼: 50m | 无法比较（单位不同）|
| **相对值** | 小明: 1.0倍身高, 大楼: 1.0倍高度 | 可以比较（都是"1倍自身"）|

**对角线归一化就是"相对值"方法**！

### 视频运动测量

同样的逻辑应用于视频：

```
场景: 物体向右移动"图像宽度的1%"

绝对测量（像素）:
- 1280×720:  物体移动 12.8 像素   
- 640×360:   物体移动 6.4 像素    ← 看起来运动少了一半！

相对测量（归一化）:
- 1280×720:  物体移动 0.01 (1% of diagonal)
- 640×360:   物体移动 0.01 (1% of diagonal)  ← 完全一样！
```

---

## ? 数学原理

### 归一化公式

```python
# 1. 计算图像对角线长度
diagonal = sqrt(width? + height?)

# 示例
1280×720:  diagonal = sqrt(1280? + 720?) = 1469
640×360:   diagonal = sqrt(640? + 360?) = 734

# 2. 计算光流幅度（像素）
flow_magnitude = sqrt(flow_x? + flow_y?)

# 示例：物体移动
1280×720:  flow_magnitude = 15.0 像素
640×360:   flow_magnitude = 7.5 像素

# 3. 归一化（除以对角线）
normalized_flow = flow_magnitude / diagonal

# 结果
1280×720:  15.0 / 1469 = 0.0102
640×360:   7.5 / 734 = 0.0102  ← 相同！
```

### 物理意义

归一化后的值表示：**运动占图像尺寸的比例**

```
normalized_flow = 0.01 
= 1% of diagonal
= "物体移动了图像对角线长度的1%"
```

---

## ? 实际案例

### 案例：建筑物抖动检测

#### 场景设置
- 同一建筑物，相同的真实抖动（1cm）
- 两台相机，不同分辨率拍摄

#### 未归一化（绝对像素）

```
相机A (高清): 1920×1080
- 1cm抖动 → 20像素位移
- mean_dynamics_score = 20.0
- 判定: "高动态，建筑物抖动严重" ? 误判

相机B (标清): 640×360  
- 1cm抖动 → 6.7像素位移
- mean_dynamics_score = 6.7
- 判定: "低动态，建筑物稳定" ? 误判

问题：相同的物理现象，不同的判定！
```

#### 归一化（相对比例）

```
相机A (高清): 1920×1080, diagonal=2203
- 1cm抖动 → 20像素 → 20/2203 = 0.0091
- mean_dynamics_score = 0.0091
- 判定: "中等动态，有轻微抖动" ?

相机B (标清): 640×360, diagonal=734
- 1cm抖动 → 6.7像素 → 6.7/734 = 0.0091
- mean_dynamics_score = 0.0091
- 判定: "中等动态，有轻微抖动" ?

结论：相同的物理现象，相同的判定！
```

---

## ? 常见疑问

### Q1: 为什么用对角线，而不是宽度或高度？

**答案**：对角线代表图像的最大可能运动范围

```
图像尺寸: 1280×720

最大水平运动: 1280 像素（从左到右）
最大垂直运动: 720 像素（从上到下）
最大斜向运动: sqrt(1280? + 720?) = 1469 像素 ← 最大

对角线 = 图像中最远的两点距离
```

**优点**：
- ? 考虑了宽度和高度
- ? 适用于任何宽高比（横屏/竖屏/方形）
- ? 物理意义明确

### Q2: 视频尺寸真的不变吗？

**答案**：完全不变！

```python
# 归一化前
video_A: (1920, 1080, 3) - RGB图像
video_B: (640, 360, 3) - RGB图像

# 归一化后
video_A: (1920, 1080, 3) - 尺寸完全相同！
video_B: (640, 360, 3) - 尺寸完全相同！

# 变化的是"如何解释光流值"
flow_A: 15.0 px → 解释为 0.0068 (相对值)
flow_B: 7.5 px  → 解释为 0.0102 (相对值)
```

### Q3: 那归一化到底在哪里发生？

**答案**：在**计算阈值比较**时

```python
# 未归一化
flow_magnitude = 15.0  # 像素
threshold = 2.0        # 像素
is_static = (15.0 < 2.0)  # False

# 归一化
flow_magnitude = 15.0 / 1469 = 0.0102  # 相对值
threshold = 0.002                       # 相对值
is_static = (0.0102 < 0.002)  # False

# 结果相同，但现在分辨率无关了！
```

---

## ? 可视化理解

### 图像坐标系 vs 归一化坐标系

```
原始图像坐标系（像素）:
┌─────────────────────────────┐
│ (0,0)           (1280,0)    │ 1280×720
│                              │
│         物体移动              │
│         ─────→               │
│         15 pixels            │
│                              │
│ (0,720)         (1280,720)  │
└─────────────────────────────┘

归一化坐标系（比例）:
┌─────────────────────────────┐
│ (0,0)           (1.0,0)     │ 单位化
│                              │
│         物体移动              │
│         ─────→               │
│         0.0102 (1.02%)      │
│                              │
│ (0,1.0)         (1.0,1.0)   │
└─────────────────────────────┘

关键：0.0102 = 15 / sqrt(1280? + 720?)
```

### 不同分辨率的对比

```
相同的物理运动 = "图像对角线的1%"

1920×1080 (diagonal=2203):
│─────────────────────────│
│    ─→ 22 px            │  22/2203 = 0.01
│─────────────────────────│

1280×720 (diagonal=1469):
│──────────────│
│   ─→ 15 px  │  15/1469 = 0.01
│──────────────│

640×360 (diagonal=734):
│───────│
│ ─→ 7px│  7/734 = 0.01
│───────│

归一化值都是 0.01 = 相同的运动！
```

---

## ? 技术细节

### 不是缩放图像！

```python
# ? 这不是我们在做的！
resized_video = cv2.resize(video, (unified_size, unified_size))

# ? 我们实际在做的
normalized_motion = motion_in_pixels / image_diagonal
```

### 归一化发生在哪里

```python
# video_processor.py - 视频保持原尺寸
frames = load_video("1920×1080.mp4")  # 尺寸: (1920, 1080, 3)
flow = compute_optical_flow(frames)   # 尺寸: (1920, 1080, 2)

# static_object_analyzer.py - 归一化计算
diagonal = sqrt(1920? + 1080?)  # = 2203
flow_magnitude = sqrt(flow_x? + flow_y?)  # 像素值
normalized_magnitude = flow_magnitude / diagonal  # 相对值

# 后续所有计算都使用 normalized_magnitude
mean_dynamics = mean(normalized_magnitude)  # 0.0-0.02 范围
dynamics_score = mean + 0.5 * std           # 0.0-0.03 范围

# unified_dynamics_scorer.py - 使用归一化值
if normalized_dynamics < 0.0034:  # 归一化阈值
    return "low_dynamic"
```

---

## ? "统一尺寸"的真正含义

### 不是统一物理尺寸

```
? 1920×1080 → 调整为 → 1280×720 (错误理解)
? 640×360  → 调整为 → 1280×720 (错误理解)
```

### 而是统一度量标准

```
? 1920×1080: 15px运动 = 0.68% of diagonal
? 1280×720:  10px运动 = 0.68% of diagonal  
? 640×360:   5px运动  = 0.68% of diagonal

"统一尺寸" = 统一到 [0, 1] 相对空间
         = 0.68% 在所有分辨率下都表示相同的运动程度
```

---

## ? 实际效果演示

### 示例：处理两个视频

```python
# 视频A: 1920×1080
flow_A = 15.0 px  # 像素位移
diagonal_A = 2203
normalized_A = 15.0 / 2203 = 0.0068

# 视频B: 640×360  
flow_B = 5.0 px   # 像素位移（小得多！）
diagonal_B = 734
normalized_B = 5.0 / 734 = 0.0068  # 相同！

# 判定
threshold = 0.002  # 归一化阈值
is_static_A = (0.0068 < 0.002)  # False - 动态
is_static_B = (0.0068 < 0.002)  # False - 动态

结论：虽然像素位移差3倍，但相对运动相同，判定一致！
```

### 未归一化的问题

```python
# 如果不归一化
threshold = 2.0  # 绝对像素阈值

is_static_A = (15.0 < 2.0)  # False - 动态 ?
is_static_B = (5.0 < 2.0)   # False - 动态 ?

# 看起来都对？但如果物体运动更小：
flow_A_small = 3.0 px
flow_B_small = 1.0 px

is_static_A = (3.0 < 2.0)  # False - 动态 ?
is_static_B = (1.0 < 2.0)  # True - 静态  ? 误判！

# 相同的物理运动，不同的判定！
```

---

## ? 归一化的真正作用

### 建立相对坐标系

```
物理世界:
┌────────────────┐
│  真实物体移动   │ → 固定距离（如5cm）
└────────────────┘

像素坐标系（绝对）:
┌────────────────┐
│ 1920×1080: 20px │ → 同样5cm，像素数不同
│ 640×360:   7px  │
└────────────────┘

归一化坐标系（相对）:
┌────────────────┐
│ 1920×1080: 0.009│ → 同样5cm，比例相同！
│ 640×360:   0.009│
└────────────────┘
```

### 数学表达

```
未归一化: pixel_motion (px)
           ↓ 分辨率依赖

归一化:   relative_motion = pixel_motion / diagonal
           ↓ 分辨率无关

物理运动 ← 更接近真实世界的运动程度
```

---

## ? 具体计算示例

### 场景：建筑物抖动

**真实情况**：建筑物抖动 0.5cm（所有视频相同）

#### 视频A: 1920×1080

```python
# 相机参数
width, height = 1920, 1080
diagonal = sqrt(1920? + 1080?) = 2203

# 抖动导致的像素位移
pixel_motion = 18.0  # 像素（取决于相机距离和焦距）

# 未归一化
dynamics_score = 18.0  # 绝对值

# 归一化
normalized_motion = 18.0 / 2203 = 0.00817
dynamics_score_normalized = 0.00817  # 相对值

# 阈值比较
threshold_abs = 2.0  # 绝对阈值
threshold_rel = 0.002  # 相对阈值

is_stable = (18.0 < 2.0)  # False - 不稳定
is_stable_norm = (0.00817 < 0.002)  # False - 不稳定（结论一致）
```

#### 视频B: 640×360（相同相机位置）

```python
# 相机参数
width, height = 640, 360
diagonal = sqrt(640? + 360?) = 734

# 同样0.5cm抖动，像素位移按比例缩放
pixel_motion = 6.0  # 像素（= 18 × 640/1920）

# 未归一化
dynamics_score = 6.0  # 绝对值（比A小3倍！）

# 归一化
normalized_motion = 6.0 / 734 = 0.00817
dynamics_score_normalized = 0.00817  # 相对值（与A相同！）

# 阈值比较
is_stable = (6.0 < 2.0)  # False - 不稳定 ?
is_stable_norm = (0.00817 < 0.002)  # False - 不稳定 ?（结论一致）

# 但如果抖动更小（0.2cm）：
pixel_motion_small = 2.4  # 像素

is_stable = (2.4 < 2.0)  # False - 不稳定 ?
is_stable_norm = (2.4/734 < 0.002)  # True - 稳定... 

# 等等，这里如果抖动真的是0.2cm
# 视频A: 2.4 × 1920/640 = 7.2px
pixel_motion_A = 7.2
is_stable_A = (7.2 < 2.0)  # False - 不稳定
is_stable_A_norm = (7.2/2203 < 0.002)  # False (0.0033 > 0.002) 

# 视频B: 2.4px
is_stable_B = (2.4 < 2.0)  # False - 不稳定
is_stable_B_norm = (2.4/734 < 0.002)  # False (0.0033 > 0.002)

# 归一化后判定一致！
```

---

## ? 关键洞察

### "统一尺寸"的正确理解

| 概念 | 含义 | 视频是否改变 |
|------|------|------------|
| **统一物理尺寸** | resize到相同分辨率 | ? 改变（缩放） |
| **统一度量标准** | 用相同的相对比例衡量 | ? 不改变 |

**我们使用的是第2种**：统一度量标准

```
类比生活：

统一物理尺寸 = 把所有人调整到相同身高（不现实）
统一度量标准 = 用"倍数"表示（小明跳0.5倍身高，大楼承受0.001倍风压）

对角线归一化 = 用"占图像尺寸的百分比"表示运动
```

---

## ? 代码中的体现

### 数据流

```python
# 1. 视频加载（尺寸不变）
video_1920 = load_video("high_res.mp4")  # shape: (N, 1920, 1080, 3)
video_640 = load_video("low_res.mp4")    # shape: (N, 640, 360, 3)

# 2. 光流计算（尺寸不变）
flow_1920 = compute_flow(video_1920)  # shape: (N-1, 1920, 1080, 2)
flow_640 = compute_flow(video_640)    # shape: (N-1, 640, 360, 2)

# 3. 归一化计算（尺寸仍不变！）
h1, w1 = 1920, 1080
diagonal_1920 = sqrt(1920? + 1080?)  # 2203
normalized_flow_1920 = flow_1920 / diagonal_1920  # shape不变: (N-1, 1920, 1080, 2)
# 每个像素的光流值从"像素"单位变成"相对于对角线的比例"单位

h2, w2 = 640, 360
diagonal_640 = sqrt(640? + 360?)  # 734
normalized_flow_640 = flow_640 / diagonal_640  # shape不变: (N-1, 640, 360, 2)

# 4. 计算动态度（使用归一化值）
mean_1920 = mean(normalized_flow_1920)  # 0.0068 (相对值)
mean_640 = mean(normalized_flow_640)    # 0.0068 (相同！)

# 5. 比较阈值（都使用相对值）
threshold_normalized = 0.002
is_static_1920 = (0.0068 < 0.002)  # False
is_static_640 = (0.0068 < 0.002)   # False - 相同判定！
```

---

## ? 总结

### 归一化三要素

1. **不改变视频尺寸** ?
   - 1920×1080 的视频保持 1920×1080
   - 640×360 的视频保持 640×360

2. **改变度量单位** ?
   - 从"像素"变成"占图像尺寸的比例"
   - 15px → 0.68% of diagonal

3. **统一比较标准** ?
   - 所有视频用相同的"相对标准"评判
   - 0.68% 在任何分辨率下都表示相同的运动程度

### 类比总结

```
对角线归一化 ≈ 百分比表示法

未归一化: "小明跑了100米，小王跑了50米"
          → 无法判断谁跑得快（不知道总距离）

归一化:   "小明跑了20%赛道，小王跑了20%赛道"  
          → 相同速度（无论赛道多长）

视频归一化: "视频A物体移动了1%图像尺寸，视频B物体移动了1%图像尺寸"
          → 相同的运动程度（无论分辨率）
```

---

## ? 延伸阅读

- 为什么选择对角线而不是宽度？ → 覆盖所有方向的运动
- 归一化会损失信息吗？ → 不会，可以反向计算
- 其他归一化方法？ → 基于宽度、基于面积等（对角线是最优）

**核心理念**：用"相对比例"而非"绝对像素"来衡量运动，使评估与分辨率解耦。

